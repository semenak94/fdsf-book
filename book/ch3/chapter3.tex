\S \textbf{3.1. Нулевой индекс.}

Напомним, что функции ФД $I_k(x)$ целого индекса $k$ существуют при $k \geqslant 0$. При $k = 0$ функция ФД выражается по формуле (2.1): $I_0(x)=log(1+e^x).$ При целых $k < 0$ функция ФД не существует, так как интеграл (1.5) расходится.

\S \textbf{3.2 Отрицательные аргументы}

\textbf{Классический ряд} (2) пригоден для практического вычисления функций
при $x \leqslant -1$. Этот ряд знакопеременный, так что ошибка не превышает первого
отброшенного слагаемого. Обычно требуется обеспечить некоторую не
абсолютную, а относительную точность $\varepsilon$. Главный член суммы в (5) есть $e^{x}$.
Если в сумме оставляется $N$ слагаемых, то относительная величина
отброшенного члена есть $e^{-Nx}/(N+1)^{k+1}$. Поэтому для заданного $х$ надо
выбирать $N$ из следующего условия:
\begin{equation}
\frac{e^{-Nx}}{(N+1)^{k+1}} \leqslant \varepsilon.
\label{eq:ref31}
\end{equation}
Можно определить $N$ из уравнения \ref{eq:ref31} каким-либо итерационным
процессом. Но при написании программы можно поступить проще: заранее
составить таблицу границ , $x_{N}$ удовлетворяющих уравнению \ref{eq:ref31}, и далее
отслеживать попадание требуемого значения $х$ в эти границы.

Когда $N$ определено, то суммировать отрезок ряда удобнее всего по схеме Горнера:
\begin{equation}
I_k(x)=\Gamma(k+1)e^{x}\Bigg(\frac{1}{1^{k+1}}-e^{x}\Bigg(\frac{1}{2^{k+1}}-e^{x}\Bigg(\frac{1}{3^{k+1}}-e^{x}\Bigg(...-e^{x}\Bigg(\frac{1}{N^{k+1}}\Bigg)\Bigg)\Bigg)\Bigg).
\end{equation}
Для 64-битовых вычислений следует полагать  $\varepsilon = 10^{-16}$. Тогда для $x = -1$
число слагаемых составляет $N = 37 - 40$; оно слабо зависит от $k$ и слегка
убывает при увеличении $k$. При $x \to -\infty$ число слагаемых $N$ быстро убывает.

Таким образом, это достаточно экономичный способ прямого вычисления функций ФД при $x \leqslant -1$. Однако, при этом остается нерешенной ещё одна проблема: как вычислять функции на отрезке $-1 \leqslant x \leqslant 0$?

\textbf{Всюду сходящийся ряд.} Для произвольных, необязательно целых,
индексов $k$ существует всюду сходящийся ряд \ref{eq:ref24}.
Коэффициенты этого ряда вычислены и приведены в Табл 2.1.
Этот ряд сходится при любом x не хуже, чем геометрическая прогрессия со
знаменателем $g = (1 + 2e^{-x})^{-1}$ . Эта сходимость неравномерная, и при $x \to +\infty$
становится очень медленной. Однако при $x \leqslant 0$ знаменатель $g \leqslant 1/3$, и
сходимость становится достаточно быстрой. Таким образом, ряд \ref{eq:ref24} удобен для
вычисления функций ФД при $x \leqslant 0$.

Ограничимся конечным числом членов ряда (3) и запишем
полученную сумму по схеме Горнера:
\begin{equation}
// gh
\end{equation}
напомним, что для целого индекса $\Gamma(k+1) = k!$. Значения коэффициентов $b_n^{(k)}$
можно непосредственно рассчитывать по формулам (5-6) или брать из Таблицы 2.1, где
они приведены с 16-ю десятичными знаками. Такого числа знаков достаточно
для вычисления с относительной точностью $\varepsilon = 10^{-16}$ (double precision).
Описанный алгоритм прост и экономичен. Поскольку коэффициенты $b_n^{k}$, то нигде не возникает вычитаний, и относительные ошибки округления могут накапливаться лишь незначительно, практически не ухудшая точность.

Определим требуемое число членов. Нас интересует относительная погрешность. Поэтому
общий множитель $2\Gamma(k + 1)g$ можно откинуть. Главный член оставшегося
произведения есть $b_0^{(k)}=1$ и все остальные члены можно сравнивать
непосредственно с ним. Все коэффициенты $b_n^{(k)}<1$ , положительны и убывают с
увеличением номера n. Это означает, что отброшенная часть ряда сходится
быстрее, чем геометрическая прогрессия с первым членом $g^{N+1}$ и знаменателем
g . Величина знаменателя возрастает от $0$ до $1/3$ при возрастании от $-\infty$ до 0.
Поэтому сумма отброшенных членов не превышает сумму этой геометрической
прогрессии $g^{N+1}/(1-g)$. Нужно, чтобы эта величина не превышала $\varepsilon$ .

Эту оценку нетрудно немного усилить. На самом деле величину откинутых
членов ряда надо сравнивать не с $b_0^{(k)}=1$, а с суммой учтенных членов ряда. Их
также можно оценить, как сумму геометрической прогрессии с первым членом
$1$ и знаменателем $g$. Тогда для сравнения вместо $\varepsilon$ надо брать величину
$\varepsilon/(1-g)$. Это дает следующую оценку:
\begin{equation}
N \geqslant \frac{ln \varepsilon}{ln g} - 1.
\end{equation}
Эта формула дает нецелое значение N. И его надо округлить вверх до целого:
\begin{equation}
N = [\frac{ln \varepsilon}{ln g}],
\end{equation}
где квадратные скобки означают целую часть числа. Даже эта оценка завышена,
т.к. она не учитывает заметного убывания $b_n^{(k)}$ при возрастании номера $n$.
Однако учет этого эффекта заметно усложнил бы алгоритм, что
нецелесообразно.

Наиболее медленная сходимость будет при $x = 0$, когда $\varepsilon = 10^{-16}$; для
$g = 1/3$ это дает $N = 33$. При $x \to -\infty$ величина $g$ быстро стремится к $0$; при
этом число членов $N$ быстро убывает.

\S \textbf{3.3. Положительный аргумент}

Для функций ФД существует точное соотношение, связывающее значения функции при положительном и
отрицательном аргументах (2.23). Для индексов $k \leqslant 4$ выше были приведены конкретные реализации (2.24) общей формулы. Поскольку для $x \leqslant 0$ алгоритм вычисления построен выше, эти формулы полностью решают вопрос вычисления функций с целым индексом.

Однако построенные выше ряды для отрицательных значений аргумента при $x~0$ требуют суммирования большого числа членов ряда, т.е. сравнительно трудоемки. В Главе № будут построены аппроксимации, существенно снижающие трудоемкость при $x \leqslant 0$.

Обсудим точность вычислений при $x > 0$. Функции отрицательного аргумента мы вычисляем с относительной точностью $\varepsilon$. Полиномиальная часть формул (2.23-2.24) вычисляется практически точно: относительная ошибка не превышает ошибки единичного округления. Сами функции ФД при $k > -1$ являются монотонно возрастаюшими по $x$. Поэтому полиномиальная часть формул (2ю23-2.24) превышает вклад функций отрицательного аргумента тем сильнее, чем больше $x$. Тем самым, при $x>0$ относительная погрешность описанного алгоритма будет заведомо меньше $\varepsilon$.