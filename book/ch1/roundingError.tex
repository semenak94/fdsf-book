\S \textbf{1.3. Погрешность округления}
\\

В данной работе рассматриваются методы прямого вычисления функций
ФД целых и полуцелых индексов, а также интегральной функции ФД с
заданной точностью. Желательно вычислять функции ФД с предельно высокой
точностью $\varepsilon$, допускаемой компьютером. Поэтому опишем точность, которую
дают распространенные сейчас процессоры при вычислении с плавающей
точкой.

Все операции с плавающей точкой
выполняются арифметическим сопроцессором (\textit{Floating Point Unit}). Его
архитектура фактически не развивается с момента принятия в $1985$ году
стандарта IEEE-754 \cite{IEEE_754}, поэтому предельная разрядность чисел остается на
уровне $80$ бит. Однако в наиболее распространенных математических
обеспечениях для записи в память используются либо $32$-битовые числа (\textit{single
precision}), либо $64$-битовые числа (\textit{double precision}). В обоих случаях не
полностью используются возможности линейки процессора. В начале $2000$-х
годов для языка С++ была возможность использовать $80$-битовые числа (\textit{long
double precision}); в настоящее время эта возможность не поддерживается и мало
где сохранилась. Для суперкомпьютерных вычислений используют $128$-
битовые числа; но вычисления делаются программными средствами на тех же
процессорах. Возможно и вычисление с произвольной разрядностью, но они
также выполняются программными средствами. Например, для языка С++ это
библиотека \textit{boost::multiprecision}.

При вычислениях с плавающей точкой побитовая запись числа выглядит
следующим образом: знак числа – 1 бит, двоичный порядок числа – $p$ бит,
мантисса – $m$ бит. Порядок числа может быть положительным или
отрицательным; но при записи в память к нему автоматически добавляется
положительная константа, равная по модулю максимально возможному
отрицательному порядку, так что в память записывается неотрицательное
число. Это эквивалентно тому, что из p разрядов порядка тратится $1$ разряд на
знак порядка и $p-1$ на модуль порядка.

При записи мантиссы также имеется небольшая "хитрость". Первый
разряд мантиссы всегда равен 1, поэтому при записи он отбрасывается. При
считывании числа в процессор этот разряд автоматически добавляется. Такой
прием позволяет фактически удлинять записываемую мантиссу на 1 бит.

Нетрудно посчитать, что максимально возможный порядок в двоичной
системе есть $2^{p-1} - 1$; для перевода в десятичную систему его нужно умножить
на $lg2$. Разрядность процессора длиннее, чем считанное из памяти число, за
исключением \textit{long double}. После вычисления результат, записанный на
процессоре, оказывается длиннее отведенного в памяти места. Поэтому при
записи результата в память производится округление. Ошибка такого
округления не превышает половины последнего отброшенного разряда. С
учетом "спрятанного" первого разряда мантиссы это означает, что
относительная ошибка округления есть $\varepsilon = 2^{-m-2}$.

В случае \textit{long double} длина числа равна линейке процессора и нельзя ни
спрятать первый разряд мантиссы, ни иметь лишние разряды для округления; в
этом случае $\varepsilon = 2^{-m}$. В Таблице $\ref{table:table_1_1}$ приведены предельные порядки $P = 2^{p-1}lg2$ и
относительные ошибки единичного округления в форме $lg\varepsilon$ для
рассмотренных выше случаев вычисления. Видно, что для случая \textit{long double}
представление числа выбрано не вполне удачно; лучше было бы взять $p = 14,m = 65$.

\begin{table}
\caption{Компьютерные числа с плавающей точкой}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
точность & бит & $p$ & $m$ & $P$ & $\lg \varepsilon$ \\
\hline
float & 32 & 8 & 23 & $\pm 38$ & -7.5 \\
double & 64 &  11 & 52 & $\pm 308$ & -16.2 \\
long double & 80 & 15 & 64 & $\pm 4932$ & -19.3\\
Quadruple double & 128 & 15 & 112 & $\pm 4932$ & -34.3 \\
\hline
\end{tabular}
\end{center}
\label{table:table_1_1}
\end{table}

Наиболее частыми являются 64-битовые вычисления, поэтому мы будем
ориентироваться на точность $16^{10}$. Вычисление \textit{long double} кажутся
заманчивыми, поскольку они повышают точность по сравнению с \textit{double} без
увеличения машинного времени. Однако разбиение числа на мантиссу и
порядок было недостаточно продумано (лучше было бы перекинуть 1 бит на
мантиссу), так что увеличение точности не столь значительно. Но $32$-битовыми
числами не стоит пренебрегать: именно такую точность дают видеокарты,
позволяющие сильно ускорять вычисления за счет конвейерной реализации.